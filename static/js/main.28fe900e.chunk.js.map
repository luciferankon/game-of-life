{"version":3,"sources":["square.js","board.js","lib.js","index.js","Game.js"],"names":["Square","this","props","value","react_default","a","createElement","className","onClick","key","React","Component","createBoard","size","Array","fill","map","x","Board","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","state","board","handleClick","bind","assertThisInitialized","start","pause","game","_this2","interval","setInterval","newBoard","startGame","setState","clearInterval","id","addAliveCell","split","_this3","row","index","worldRow","square","updateCellWithInput","cells","element","possibleCombinations","generateValidNeighbours","grid","currPosition","currentPosition","delta","filter","position","bottomRight","length","isWithin","checkValidPosition","checkNeighbourState","_validNeighbours$redu","reduce","neighbour","push","checkState","defineProperty","checkNextState","neighbours","currentState","generateInitialWorld","inputs","topLeft","isGreaterOrEqual","element1","element2","findRelativeWorld","currGeneration","bounds","makePositionRelativeWith","makePositionRelative","findPointInsideBoard","isWithinBound","Game","input","aliveCells","height","width","_findHeightWidth","findHeightWidth","updatedWorld","oldGrid","slice","r","c","nextState","updateGrid","generateRelativeWorld","initCells","relativeTopLeft","i","j","world","nextGeneration","cell","ReactDOM","render","src_board","document","getElementById"],"mappings":"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","file":"static/js/main.28fe900e.chunk.js","sourcesContent":["import React from \"react\"\n\nclass Square extends React.Component{\n\n  render(){\n    if(this.props.value === 1){\n      return <td className=\"live-cell\" onClick={this.props.onClick} key=\"s\"> </td>      \n    } \n    return (\n      <td className=\"dead-cell\" onClick={this.props.onClick} key=\"s\"> </td>\n    )\n  }\n}\n\nexport default Square","import React from \"react\";\nimport Square from \"./square\";\n\nconst createBoard = function(size) {\n  return new Array(+size[0]).fill(\" \").map(x => new Array(+size[1]).fill(\" \"));\n};\n\nclass Board extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { board: createBoard(this.props.size) };\n    this.handleClick = this.handleClick.bind(this);\n    this.start = this.start.bind(this);\n    this.pause = this.pause.bind(this);\n    this.game = this.props.game;\n  }\n\n  start() {\n    this.interval = setInterval(() => {\n      let newBoard = this.game.startGame();\n      this.setState({ board: newBoard });\n    }, 500);\n  }\n\n  pause(){\n    clearInterval(this.interval);\n  }\n\n  handleClick(id) {\n    this.game.addAliveCell(id.split(\"\"));\n    this.setState(state=>{\n      state.board[id[0]][id[1]] = 1;\n    })\n    this.setState(this.state.board);\n  }\n\n  render() {\n    const board = this.state.board.map((row, index) => {\n      const worldRow = row.map((value, id) => {\n        return (\n          <Square\n            value={value}\n            onClick={this.handleClick.bind(null, \"\" + index + id)}\n            key={\"\" + index + id}\n          />\n        );\n      });\n      return <tr key={\"a\"+index}>{worldRow}</tr>;\n    });\n    return (\n      <div>\n        <table><tbody>{board}</tbody></table>\n        <div>\n          <button onClick={this.start}>Start</button>\n        </div>\n        <div>\n          <button onClick={this.pause}>pause</button>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Board;\n","const ALIVE = 1;\nconst DEAD = 0;\n\nconst updateCellWithInput = function(cells, element) {\n  cells[element[0]][element[1]] = 1;\n  return cells;\n};\n\nconst possibleCombinations = [\n  [-1, -1],\n  [-1, 0],\n  [-1, 1],\n  [0, -1],\n  [0, 1],\n  [1, -1],\n  [1, 0],\n  [1, 1]\n];\n\nconst generateAddCoordinates = function(currentPosition) {\n  return function(delta) {\n    let rowIndex = currentPosition[0] + delta[0];\n    let columnIndex = currentPosition[1] + delta[1];\n    return [rowIndex, columnIndex];\n  };\n};\n\nconst checkValidPosition = function(grid) {\n  return function(position) {\n    let topLeft = [0, 0];\n    let bottomRight = [grid.length - 1, grid[0].length - 1];\n    return isWithin(topLeft, bottomRight, position);\n  };\n};\n\nconst generateValidNeighbours = function(grid, currPosition) {\n  let possibleNeighbours = possibleCombinations.map(\n    generateAddCoordinates(currPosition)\n  );\n  return possibleNeighbours.filter(checkValidPosition(grid));\n};\n\nconst checkState = function(grid) {\n  return function(neighbour, position) {\n    let state = grid[position[0]][position[1]];\n    neighbour[state].push(position);\n    return neighbour;\n  };\n};\n\nconst checkNeighbourState = function(grid, position) {\n  let validNeighbours = generateValidNeighbours(grid, position);\n  return validNeighbours.reduce(checkState(grid), { [ALIVE]: [], [DEAD]: [] });\n};\n\nconst checkNextState = function(neighbours, currentState) {\n  let aliveNeighbours = neighbours[ALIVE].length;\n  let cellRules = [0, 0, currentState, 1, 0, 0, 0, 0, 0];\n  return cellRules[aliveNeighbours];\n};\n\nexport const updateGrid = function(oldGrid) {\n  let grid = oldGrid.map(x => x.slice());\n  for (let r = 0; r < oldGrid.length; r++) {\n    for (let c = 0; c < oldGrid[r].length; c++) {\n      let neighbours = checkNeighbourState(oldGrid, [r, c]);\n      let nextState = checkNextState(neighbours, oldGrid[r][c]);\n      grid[r][c] = nextState;\n    }\n  }\n  return grid;\n};\n\nexport const generateInitialWorld= function(cells, inputs) {\n  inputs.reduce(updateCellWithInput, cells);\n  return cells;\n}\n\nexport const generateRelativeWorld = function(grid, currGeneration, bounds) {\n  currGeneration = findPointInsideBoard(currGeneration, bounds);\n  currGeneration = findRelativeWorld(currGeneration, bounds);\n  let world = generateInitialWorld(grid, currGeneration);\n  return world;\n};\n\nconst isWithin = function(topLeft, bottomRight, position) {\n  return (\n    isGreaterOrEqual(position[0], topLeft[0]) &&\n    isGreaterOrEqual(bottomRight[0], position[0]) &&\n    isGreaterOrEqual(position[1], topLeft[1]) &&\n    isGreaterOrEqual(bottomRight[1], position[1])\n  );\n};\n\nconst isGreaterOrEqual = function(element1, element2) {\n  return element1 >= element2;\n};\n\nconst findRelativeWorld = function(currGeneration, bounds) {\n  let makePositionRelativeWith = makePositionRelative.bind(\n    null,\n    bounds.topLeft\n  );\n  return currGeneration.map(makePositionRelativeWith);\n};\n\nconst findPointInsideBoard = function(currGeneration, bounds) {\n  let isWithinBound = isWithin.bind(null, bounds.topLeft, bounds.bottomRight);\n  return currGeneration.filter(isWithinBound);\n};\n\nexport const makePositionRelative = function(topLeft, position) {\n  return [position[0] - topLeft[0], position[1] - topLeft[1]];\n};\n\nexport const findHeightWidth = function(bounds) {\n  let height = bounds.bottomRight[0] - bounds.topLeft[0] + 1;\n  let width = bounds.bottomRight[1] - bounds.topLeft[1] + 1;\n  return { height: height, width: width };\n};","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Board from \"./board\"\nimport Game from \"./Game\"\n\nconst game = new Game();\n\nReactDOM.render(<Board size={[9,9]} game={game}/>, document.getElementById('root'));\n","import {\n  findHeightWidth,\n  generateInitialWorld,\n  generateRelativeWorld,\n  updateGrid,\n  makePositionRelative\n} from \"./lib\";\n\nclass Game {\n  constructor() {\n    this.input = {\n      size: [9, 9],\n      bounds: { topLeft: 0, bottomRight: 8 }\n    };\n    this.aliveCells = [];\n  }\n\n  initCells(height, width) {\n    let cells = new Array(height).fill(width);\n    return cells.map(x => new Array(x).fill(0));\n  }\n\n  nextGeneration(currGeneration, bounds) {\n    let { height, width } = findHeightWidth(bounds);\n    let grid = this.initCells(height, width);\n    let relativeWorld = generateRelativeWorld(grid, currGeneration, bounds);\n    let updatedWorld = updateGrid(relativeWorld);\n    let aliveCells = [];\n    let relativeTopLeft = bounds.topLeft.map(x => -x);\n    for (let i in updatedWorld) {\n      for (let j in updatedWorld[i]) {\n        if (updatedWorld[i][j] === 1) {\n          aliveCells.push([+i, +j]);\n        }\n      }\n    }\n    return aliveCells.map(makePositionRelative.bind(null, relativeTopLeft));\n  }\n\n  startGame() {\n    let height = +this.input.size[0];\n    let width = +this.input.size[1] || height;\n    let world = this.initCells(height, width);\n    this.aliveCells = this.nextGeneration(this.aliveCells, {\n      topLeft: [0, 0],\n      bottomRight: [height - 1, width - 1]\n    });\n    let nextGen = generateInitialWorld(world, this.aliveCells);\n    return nextGen;\n  }\n\n  addAliveCell(cell) {\n    this.aliveCells.push(cell);\n  }\n}\n\nexport default Game;\n"],"sourceRoot":""}